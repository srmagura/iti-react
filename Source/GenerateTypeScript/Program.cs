using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Text;
using MoreLinq;

namespace GenerateTypeScript
{
    // Automatically runs post build
    class Program
    {
        private static readonly string SourceDir =
            Directory.GetParent(AppDomain.CurrentDomain.BaseDirectory).Parent
                .Parent.Parent.FullName;

        private static readonly string TypeScriptDir = Path.Combine(SourceDir, @"Website\Scripts");

        private static readonly string AutoGeneratedMessage = "// Auto-generated by GenerateTypeScript\n";

        /// <summary>
        /// Create an index.ts for the Scripts\Models directory so that it's easier to import models from
        /// other files
        /// </summary>
        private static void GenerateModelsIndex()
        {
            var modelsDir = Path.Combine(TypeScriptDir, @"Models");

            var output = new StringBuilder();
            output.Append(AutoGeneratedMessage);

            foreach (var path in Directory.EnumerateFiles(modelsDir, "*.ts", SearchOption.AllDirectories))
            {
                var noExtension = Path.GetFileNameWithoutExtension(path);
                output.Append($"export * from './{noExtension}';\n");
            }

            var outputPath = Path.Combine(modelsDir, "index.ts");
            File.WriteAllText(outputPath, output.ToString());
            PrintWrittenMessage(outputPath);
        }

        private class MvcAction
        {
            public string Controller { get; set; }
            public string Action { get; set; }
        }

        private static List<MvcAction> GetMvcActions()
        {
            var assemblyPath = Path.Combine(SourceDir, @"Website\bin\Debug\net47\Website.exe");
            Assembly asm;

            try
            {
                asm = Assembly.LoadFrom(assemblyPath);
            }
            catch
            {
                throw new Exception($"Could not load Website assembly from {assemblyPath}.");
            }

            // comparing strings, not types, because I was getting an error similar to https://stackoverflow.com/a/345464/752601
            var controllers = asm.GetTypes()
                .Where(type => type.Name.EndsWith("Controller") &&
                               !type.Name.Equals("BaseController") &&
                               !type.Name.Equals("Controller")).ToList();

            List<MethodInfo> actionMethodInfos = controllers
                // Filter out duplicate method names on the same controller - 
                // this can happen if there is a method for GET and a method for POST
                .SelectMany(type => type.GetMethods().DistinctBy(method => method.Name))
                // Filter out methods declared on BaseController
                .Where(method => method.IsPublic && controllers.Contains(method.DeclaringType))
                .ToList();

            return actionMethodInfos.Select(info => new MvcAction
            {
                Controller = info.DeclaringType.Name.Replace("Controller", ""),
                Action = info.Name
            }).ToList();
        }

        /// <summary>
        /// Generates Url.ts so that we can access URLs in a type-safe manner from TypeScript
        /// </summary>
        private static void GenerateUrls()
        {
            var output = new StringBuilder();
            output.Append(AutoGeneratedMessage);
            output.Append("import { getUrl } from 'Util/UrlUtil';\n\n");

            foreach (var mvcAction in GetMvcActions())
            {
                output.Append($"export const get_{mvcAction.Controller}_{mvcAction.Action}: () => string = () => getUrl(");
                output.Append($"{{ controller: '{mvcAction.Controller}', action: '{mvcAction.Action}' }});\n");
            }

            var outputPath = Path.Combine(TypeScriptDir, "Url.ts");
            File.WriteAllText(outputPath, output.ToString());
            PrintWrittenMessage(outputPath);
        }

        /// <summary>
        /// Imports each page. This saves us from having to add a new import statement when a 
        /// new view is added.
        /// 
        /// We import pages dynamically, so these import statements don't
        /// actually get used during runtime. The reason why we're doing this is so that
        /// Webpack knows to recompile when a page changes.
        /// </summary>
        //private static void GeneratePageIndex()
        //{
        //    string GetPageVariableName(MvcAction mvcAction)
        //    {
        //        return $"{mvcAction.Controller}{mvcAction.Action}Page";
        //    }

        //    var output = new StringBuilder();
        //    output.Append(AutoGeneratedMessage);

        //    foreach (var mvcAction in GetMvcActions())
        //    {
        //        var modulePath = $"Pages/{mvcAction.Controller}/{mvcAction.Action}";
        //        var filePath = Path.Combine(TypeScriptDir, modulePath + ".tsx");
        //        Console.WriteLine(filePath);
        //        if (File.Exists(filePath))
        //        {
        //            output.Append("export { Page as " + GetPageVariableName(mvcAction) + "} from ");
        //            output.Append($"'{modulePath}';\n");
        //        }
        //    }

        //    var outputPath = Path.Combine(TypeScriptDir, "Pages/PageIndex.ts");
        //    File.WriteAllText(outputPath, output.ToString());
        //    PrintWrittenMessage(outputPath);
        //}

        private static void PrintWrittenMessage(string path)
        {
            Console.WriteLine($"Wrote file {Path.GetFileName(path)}");
        }

        public static void Main()
        {
            try
            {
                GenerateModelsIndex();
                //GeneratePageIndex();
                GenerateUrls();
            }
            catch (Exception e)
            {
                Console.WriteLine("GenerateTypeScript failed with error: " + e.Message);
            }
        }
    }
}
